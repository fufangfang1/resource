## 面试题

### vue

#### 简述计算属性的缓存原理

答：

computed 的计算属性有缓存机制，只有当其依赖的响应式数据发生变化时才会清空缓存重新计算结果。其缓存机制本质是通过一个 dirty 属性控制的，只有 dirty 为 true 时才会重新计算结果替换缓存。dirty 只有当其响应式数据发送变化时才会设置为 true，重新计算后会再次被设置为 false。

#### 简述计算属性与 watch 的区别

答：

1. 计算属性在调用时需要在模板中渲染，修改计算所依赖元数据；watch 在调用时只需修改元数据。

2. 计算属性默认深度依赖，watch 默认浅度观测。

3. 计算属性适合做筛选，不可异步；watch 适合做执行异步或开销较大的操作。

![](./image/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8Ewatch%E5%8C%BA%E5%88%AB.jpg)

> 补充:

注意：不要使用箭头函数来定义 watch 函数，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例。

#### 简述 vue2 的数据响应式原理

答：

Vue 的响应式原理： 核心是通过 ES5 的 Object.defindeProperty 进行==数据劫持==， 然后利用 get 和 set 方法进行数据的获取和设置， 这时的 data 中声明的属性都将被添加到 get 和 set 中， 当读取 data 中的数据时， 自动调用 get 方法， 当修改数据时 或者数据发生改变时 自动调用 set 方法， 去侦听检测数据的变化 同时会通知观察者 Watcher， 观察者 Watcher 自动重新触发 render， 当前组件 （子组件不会重新渲染） 生成新的虚拟 DOM 树， Vue 的框架会遍历并对比新旧虚拟 DOM 树上面的每个节点的差别， 并记录下来， 最后加载操作， 将所有记录下来的节点 局部修改到真实的 DOM 树上

> 补充理解 1：

三个最重要的对象：

1. Observer 对象：将 Vue 中的数据对象在初始化过程中转换为 Observer 对象。
2. Watcher 对象：将模板和 Observer 对象结合在一起生成 Watcher 实例，Watcher 是订阅者中的订阅者。
3. 纽带，每一个 Observe r 都有一个 Dep 实例，用来存储订阅者 Watcher。

> 补充理解 2:

响应式原理主要就是通过==数据劫持，依赖收集，派发更新==的方式来实现的

1. 数据劫持，vue2 是通过 Object。defineProperty 来将对象的每一个属性转化成 set，get。其中修改对象的属性时 就会触发 set， 使用对象的属性时就会触发 get

2. 依赖收集。就是在渲染视图时 将 watcher 和具体的属性，通过发布订阅者模式管理，这样数据改变之后就能更精准的更新视图

3. 派发更新：它就是通过 dep 来执行 watcher 的 notify 方法。

#### 简述 vue 的路由导航守卫。

答：

> 路由守卫分类：

1.  全局守卫: 是指路由实例上直接操作的钩子函数，特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数。

2.  独享守卫: 是指在单个路由配置的时候也可以设置的钩子函数。

3.  组件守卫: 是指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数

> 路由方法：

1. 全局守卫：

- 全局前置守卫 beforeEach（to，from， next）在路由跳转前触发，这个钩子作用主要是用于登录验证。

```js
const router = new VueRouter({ ... })

router.beforeEach((to, from, next) => {
  // ...
})
```

- 全局解析守卫 beforeResolve（to，from， next）这个钩子和 beforeEach 类似，也是路由跳转前触发，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，即在 beforeEach 和 组件内。

- 全局后置钩子 afterEach（to，from）和 beforeEach 相反，它是在路由跳转完成后触发，它发生在 beforeEach 和 beforeResolve 之后，beforeRouteEnter（组件内守卫）之前。这些钩子不会接受 next 函数也不会改变导航本身

```js
router.afterEach((to, from) => {
  // ...
});
```

2. 独享守卫

- 路由独享守卫 beforeEnter（to，from， next）和 beforeEach 完全相同，如果两个都设置了，beforeEnter 则在 beforeEach 之后紧随执行。在路由配置上直接定义 beforeEnter 守卫

```js
const router = new VueRouter({
  routes: [
    {
      path: "/foo",
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      },
    },
  ],
});
```

3. 组件守卫

- 组件前置守卫 beforeRouteEnter（to，from， next）
  该钩子在全局守卫 beforeEach 和独享守卫 beforeEnter 之后，全局 beforeResolve 和全局 afterEach 之前调用，要注意的是该守卫内访问不到组件的实例，也就是 this 为 undefined。因为它在组件生命周期 beforeCreate 阶段触发，此时的新组件还没有被创建。在这个钩子函数中，可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数

```js
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```

- 组件更新守卫 beforeRouteUpdadte（to，from， next）
  在当前路由改变时，并且该组件被复用时调用，可以通过 this 访问实例

- 组件离开守卫 beforeRouteLeave（to，from， next）
  导航离开该组件的对应路由时调用，可以访问组件实例 this。这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next( false )来取消

```js
beforeRouteLeave (to, from , next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
```

> 完整的导航解析过程

1. 触发进入其它路由
2. 调用要离开路由的组件守卫 beforeRouteLeave
3. 调用全局的前置守卫 beforeEach
4. 在重用的组件里调用 beforeRouteUpdate
5. 在路由配置里调用 beforeEnter
6. 解析异步路由组件
7. 在将要进入的路由组件中调用 beforeRouteEnter
8. 调用全局的解析守卫 beforeResolve
9. 导航被确认
10. 调用全局的后置钩子 afterEach。
11. 触发 DOM 更新 mounted。
12. 执行 beforeRouteEnter 守卫中传给 next 的回调函数

#### 简述 v-module 指令的实现原理

答：

v-model 其实是个语法糖，它实际上是做了两步动作：
1、绑定数据 value
2、触发输入事件 input

```js

// 第一行代码是第二行代码的语法糖

 <input type="text" v-model="username">


<input v-bind:value='username' v-on:input='$event.target.value'>

//第二行代码又可以简写成下面这样：

 <input type="text" :value="username" @input="username=$event.target.value">

```

#### 简述组件中的 data 为什么是一个函数

答：因为组件是用来复用的，如果组件中 data 是一个对象，那么这样的作用域没有隔离，子组件中的 data 属性值会相互影响。

如果组件 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立拷贝，组件实例中的 data 属性值不会被相互影响。

### js

#### 简述事件循环

答：

![事件循环图解](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/17/1721eaa3d2c905c5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

事件循环：就是一个执行消息队列的机制

首先在这套机制里有这三个东东：执行栈、微任务、宏任务

- 执行栈，是用来执行我们写的代码的。

- 微任务，和宏任务一样也是存代码用的，等待被执行栈执行的，它也是个队列，先进先出。

- 宏任务，可以理解为存放等待执行栈中执行代码用的，它是个队列，先进先出。

> 宏任务包括：
> 主任务（例如一个 script 标签，在 html 中一个 script 标签就是一个宏任务）
> setTimeout
> setInterval
> I/O
> UI 交互事件
> postMessage
> MessageChannel
> setImmediate(Node.js 环境)

> 微任务包括：
> Promise.then
> Object.observe
> MutaionObserver
> process.nextTick(Node.js 环境）

> 执行过程：

所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。

一旦“执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
先执行微队列，后执行宏队列。

主线程不断重复上面的第三步。

#### 跨域是如何产生的以及如何解决

答：

> 什么是跨域

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源

> 如何产生

跨域是由浏览器的==同源策略==造成的，是浏览器对 javascript 施加的安全限制。

同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域。

> 如何解决

JSONP

JSONP 能够跨域的原理就是:动态创建 script 标签，利用 script 标签的 src 请求没有跨域的限制。

代码举例：

```js
// 代码定义一个全局函数，然后把这个函数名添加到 script 标签中 src 属性的参数 callback 中，script 的 src 就是需要跨域的请求。服务端收到请求之后，将数据放入 callback 属性的属性值中:updateList(“somedata”)，然后返回给客户端

function updateList(data) {
  console.log(data);
}
let tag = document.createElement("script");
tag.src = "http://otherdomain.com/request?callback=updateList";
document.head.appendChild(tag);
```

#### 简述事件三要素

答：

- 事件源：哪一个标签需要发生动态改变（制作时需要获取元素改变元素和被改变元素）；

- 事件类型：指对标签执行的一系列静态页面的操作行为：如：点击、悬浮、触发未弹回、触发弹回等......
- 事件处理程序：利用函数的方法去传参改变相应数值

#### 简述事件绑定的方式以及区别

答：

- 事件绑定分三种常用的方法:
  (1)在 DOM 元素中直接绑定（行内绑定）
  (2)在 js 代码中绑定（动态绑定）
  (3)绑定事件监听函数（事件监听）

> 详解

DOM 元素中直接绑定:

```js
<input type='button' onclick='fn()'>
    <script>
        function fn(){
            console.log('hello');
    }
    </script>
```

在 js 代码中直接绑定:

```js
document.getElementById("btn").onclick = function () {
  console.log("hello");
};
```

绑定事件监听函数 addEventListener()或 attachEvent()

事件监听：分别定义了 3 个事件阶段，依次是捕获阶段，目标阶段，冒泡阶段

事件监听 chrome 浏览器下:
element.addEventListener(DOM 事件名，事件触发时执行函数，指定是否是冒泡执行,false 是冒泡)

```js
document.getElemengById("btn1").addEventListener("click", aaa);
function aaa() {
  console.log("aaaa");
}
```

> 区别

区别一：

行内绑定时，函数内部的 this 指向为 window，

动态绑定时，内部 this 指向为该 dom 元素，

事件监听的绑定方式，传入的参数有三个，第一个为事件名称，第二个为回调函数，第三个为是否事件传递方式是捕获，true 为捕获，false 为冒泡，默认为 false 冒泡。

区别二：

行内绑定：编写简单，但 css 和 js 耦合深，不分离

动态绑定：让 css 和 js 解耦分离，但只能绑定一个事件，多个事件会被最后绑定的事件覆盖

事件监听：让 css 和 js 解耦分离，并且可以绑定多个事件

#### 简述事件委托

答：

事件委托也叫事件代理，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是：DOM 元素的事件冒泡。

通过 e.target 获取当前元素。

> 优点

1. 可以大量节省内存占用，减少事件注册，比如在 ul 上代理所有 li 的 click 事件。

2. 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）

#### 简述什么是原型和原型链

答：

原型：每一个 javascript 对象(除 null 外)创建的时候，都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中‘继承’属性。

![原型图解](./image/%E5%8E%9F%E5%9E%8B.png)

原型链：每个构造函数都有一个原型对象（prototype），原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(\_ _proto_ \_)。那么假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链。

![原型链图解](./image/%E5%8E%9F%E5%9E%8B%E9%93%BE.png)

#### 简述预解析流程

答：

1. 函数执行时会创建一个 AO 对象
2. 将形参和变量声明提升，赋值 undefined
3. 实参与形参统一
4. 在函数体内找函数声明，如果形参或变量与函数声明 名字相同，那就把函数声明赋值给形参或变量。

#### 简述 js 数据类型

答：

![](./image/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg)

- 基本数据类型(值类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、symbol（ES6 新增）。

> 基本数据类型存储在栈内存中,数据赋值后，就形成了对应的名值对；

- 引用数据类型（对象类型）：对象类型、函数，对象类型又分为：Object 对象、Array 数组、RegExp 正则、Date 时间对象、Math 数学对象

> 引用数据类型存储在堆内存中,赋值时，只是把一个值的地址赋予了一个变量；

#### 如何判断一个数据是数组

答：

1. instanceof

instanceof 运算符用于检验构造函数的 prototype 属性是否出现在对象的原型链中的任何位置，返回一个布尔值。

```js
let a = [];
a instanceof Array; //true
let b = {};
b instanceof Array; //false
```

2. construator

实例的构造函数属性 constructor 指向实例本身，那么通过 constructor 属性也可以判断是否为一个数组。

```js
let a = [1, 3, 4];
a.constructor === Array; //true
```

> 对于已知实例类型，可以很方便的进行判断，需要注意的是，construator 和 instanceof 一样，判断会存在多个全局环境的问题，典型的就是 iframe 标签会同时存在一个或者多个全局环境，会影响到这 2 种方法的判断结果

3. Object.prototype.String.call()

Object.prototype.toString().call()可以获取到对象的不同类型，例如

```js
//检验是否为数组
let a = [1, 2, 3];
Object.prototype.toString.call(a) === "[object Array]"; //true
//检验是否是函数
let b = function () {};
Object.prototype.toString.call(b) === "[object Function]"; //true
//检验是否是数字
let c = 1;
Object.prototype.toString.call(c) === "[object Number]"; //true
//检验是否为对象
let d = {};
Object.prototype.toString.call(d) === "[object Object]"; //true
```

4. Array.isArray() 用于确定传递的值是否是一个数组，返回一个布尔值。

```js
let a = [1, 2, 3];
Array.isArray(a); //true
```

#### 防抖与节流

答：

> 防抖

防抖策略: 当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。（只被执行一次）

好处: 能够保证用户在频繁触发某些事件的时候,不会频繁的执行回调,==只会被执行一次==

应用场景:

1. 用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源；

2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖

3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存

4. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖。

实现思路：

==防抖重点在于清零==

```js
const debounce = (fn, time) => {
  // time时间内的触发，都会导致重新计时
  let timeout = null;
  return function () {
    // 清除上个定时器，避免开太多定时器占内存
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, time);
  };
};
```

> 节流

节流策略:可以==减少==一段时间内事件的触发频率。（执行次数＞=1）

应用场景：

1. 鼠标不断触发某事件时,如点击,只在单位事件内触发一次.

2. 懒加载时要监听计算滚动条的位置,但不必要每次滑动都触发,可以降低计算频率,而不必要浪费 CPU 资源

3. 浏览器播放事件，每隔一秒计算一次进度信息等

4. scroll 事件，每隔一秒计算一次位置信息等

实现思路：

==节流重点在于开关锁==

```js
let flag = true;
		if (flag) {
          // 进入条件后 改变flag的值为false
          flag = false
          // 定义一个延时函数 在最后把flag的值变为true
          // 这样就可以确保每秒 函数只会执行一次
          setTimeout(function(){
            console.log(1);
			...执行函数
          flag = true
        },1000)
      }
```

> 防抖和节流的区别

防抖:如果事件被频繁触发,防抖保证只能有一次触发生效,前面 N 多次触发都会被忽略.

节流:如果时间被频繁触发,节流能减少事件触发的频率,因此,节流是有选择性的执行一部分事件.

总结: 函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。

> 防抖与节流

![](./image/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.png)

#### for of 与 for in 的区别

答：

> 区别一：

循环数组：for in 和 for of 都可以循环数组，for in 输出的是数组的 index 下标，而 for of 输出的是数组的每一项的值。

> 区别二：

循环对象：for in 可以遍历对象，for of 不能遍历对象，只能遍历带有 iterator 接口的，例如 Set,Map,String,Array，arguments 等。

（补充：一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator 接口, 就可以使用 for of 循环。）

> 总结：

for in 适合遍历对象，for of 适合遍历数组。

for in 遍历的是数组的索引，对象的属性名（key），以及原型链上的属性。

for of 可以与 break、continue 和 return 配合使用,也就是说 for of 循环可以随时退出循环。

### html/css

#### 简述元素绝对居中的方式

> 方式一：弹性布局

父元素 display 为 flex，子元素顺着父容器的主轴居中排列

```js
html{
  height:100%;
  display:flax;
  align-items:center;
  //  justify-content 属性定义了浏览器如何分配顺着父容器主轴弹性元素之间及其周围的空间
  justify-content:center;
}
```

> 方法二：绝对定位

top 和 left 固定后用 margin 移动元素

```js
.container{
  width:1200px;
  height:210px;
  background-color:red;
  position:absolute;
  top:50%;
  left:50%
  margin-left:-600px;//宽度的一半
  margin-top:-105px;//高度的一半
}
```

> translate 进行平移

移动自身的 50%

```js
.container{
  width:1200px;
  height:210px;
  background-color:red;
  position:absolute;
  top:50%;
  left:50%
  transform:translate(-50%,-50%);
}
```

> margin:auto

四角定位，外边距把盒子挤到中间

```js
element {
  //宽高写不写都能绝对居中
width: 600px;
height: 400px;
position: absolute;
left: 0;
top: 0;
right: 0;
bottom: 0;
margin: auto; /* 有了这个就自动居中了 */
}
```

#### 简述如何解决一像素问题

答：

运用：transform：scale（0.5）

> 具体代码：

```js
// html

 <body>
    <div class="dowebok"></div>
  </body>


// 原理：css ::after里面的width:200%;height:200%就是把after元素放大两倍,原来的边框像素还是1px原来的大小,再用tranform:translate(.5)是把元素压缩,原来的1px还是1px,但是被压缩成一半的大小了,所以看起来细了

// 解决一条边一像素问题
#dowebok::after {
            content: '';
            display: block;
            // 解决哪条边，看情况设置
            width: 1px;
            height: 200%;

            position: absolute;
            right: 0;
            top: 0;
            box-sizing: border-box;
            background: black;
            // 以元素左上角为基准来进行缩放
            transform-origin: 0 0;
            // 默认以元素中心进行缩放
            transform: scale(0.5);
        }
//解决四条边一像素问题
        #dowebok::after {
            content: '';
            display: block;
            width: 200%;
            height: 200%;
            position: absolute;
            left: 0;
            top: 0;
            box-sizing: border-box;
            border: 1px solid black;
            transform-origin: 0 0;
            transform: scale(0.5);
        }
```

> 补充问题：为什么会产生一像素问题

答：

因为在移动端，屏幕分辨率的不同，现在分为一倍屏、二倍屏、三倍屏。在不同的分辨率上，有可能一像素被渲然成二个像素点或者三个像素点，所以在实际写代码的时候，我们写的 border: 1px solid #000; 可能实际被渲然为 2px/3px；

> 下面是逼格高的回答

物理像素，又称设备像素，在同一个设备上，它的物理像素是固定的，设备厂商出厂就设置好了，即：一个设备的分辨率是固定的。
逻辑像素，又称 CSS 像素，viewport 中的一个小方格。我们在写 css 代码的时候，用的就是 css 像素。

像素比，物理像素和逻辑像素之比。当比例是 1：1 时，表示 1 个物理像素显示一个 css 像素；当比例为 2：1 时，表示 4 个物理像素显示 1 个逻辑像素。
